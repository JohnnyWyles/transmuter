/**
* This file was automatically generated by @cosmwasm/ts-codegen@0.24.0.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/

import { CosmWasmClient, SigningCosmWasmClient, ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee } from "@cosmjs/amino";
import { ExecuteMsg, Uint128, Coin, InstantiateMsg, QueryMsg, Decimal, CalcInAmtGivenOutResponse, CalcOutAmtGivenInResponse, Addr, GetAdminCandidateResponse, GetAdminResponse, GetShareDenomResponse, GetSharesResponse, GetSwapFeeResponse, GetTotalPoolLiquidityResponse, GetTotalSharesResponse, IsActiveResponse, SpotPriceResponse } from "./Transmuter.types";
export interface TransmuterReadOnlyInterface {
  contractAddress: string;
  getShares: ({
    address
  }: {
    address: string;
  }) => Promise<GetSharesResponse>;
  getShareDenom: () => Promise<GetShareDenomResponse>;
  getSwapFee: () => Promise<GetSwapFeeResponse>;
  isActive: () => Promise<IsActiveResponse>;
  getTotalShares: () => Promise<GetTotalSharesResponse>;
  getTotalPoolLiquidity: () => Promise<GetTotalPoolLiquidityResponse>;
  spotPrice: ({
    baseAssetDenom,
    quoteAssetDenom
  }: {
    baseAssetDenom: string;
    quoteAssetDenom: string;
  }) => Promise<SpotPriceResponse>;
  calcOutAmtGivenIn: ({
    swapFee,
    tokenIn,
    tokenOutDenom
  }: {
    swapFee: Decimal;
    tokenIn: Coin;
    tokenOutDenom: string;
  }) => Promise<CalcOutAmtGivenInResponse>;
  calcInAmtGivenOut: ({
    swapFee,
    tokenInDenom,
    tokenOut
  }: {
    swapFee: Decimal;
    tokenInDenom: string;
    tokenOut: Coin;
  }) => Promise<CalcInAmtGivenOutResponse>;
  getAdmin: () => Promise<GetAdminResponse>;
  getAdminCandidate: () => Promise<GetAdminCandidateResponse>;
}
export class TransmuterQueryClient implements TransmuterReadOnlyInterface {
  client: CosmWasmClient;
  contractAddress: string;

  constructor(client: CosmWasmClient, contractAddress: string) {
    this.client = client;
    this.contractAddress = contractAddress;
    this.getShares = this.getShares.bind(this);
    this.getShareDenom = this.getShareDenom.bind(this);
    this.getSwapFee = this.getSwapFee.bind(this);
    this.isActive = this.isActive.bind(this);
    this.getTotalShares = this.getTotalShares.bind(this);
    this.getTotalPoolLiquidity = this.getTotalPoolLiquidity.bind(this);
    this.spotPrice = this.spotPrice.bind(this);
    this.calcOutAmtGivenIn = this.calcOutAmtGivenIn.bind(this);
    this.calcInAmtGivenOut = this.calcInAmtGivenOut.bind(this);
    this.getAdmin = this.getAdmin.bind(this);
    this.getAdminCandidate = this.getAdminCandidate.bind(this);
  }

  getShares = async ({
    address
  }: {
    address: string;
  }): Promise<GetSharesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_shares: {
        address
      }
    });
  };
  getShareDenom = async (): Promise<GetShareDenomResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_share_denom: {}
    });
  };
  getSwapFee = async (): Promise<GetSwapFeeResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_swap_fee: {}
    });
  };
  isActive = async (): Promise<IsActiveResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      is_active: {}
    });
  };
  getTotalShares = async (): Promise<GetTotalSharesResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_total_shares: {}
    });
  };
  getTotalPoolLiquidity = async (): Promise<GetTotalPoolLiquidityResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_total_pool_liquidity: {}
    });
  };
  spotPrice = async ({
    baseAssetDenom,
    quoteAssetDenom
  }: {
    baseAssetDenom: string;
    quoteAssetDenom: string;
  }): Promise<SpotPriceResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      spot_price: {
        base_asset_denom: baseAssetDenom,
        quote_asset_denom: quoteAssetDenom
      }
    });
  };
  calcOutAmtGivenIn = async ({
    swapFee,
    tokenIn,
    tokenOutDenom
  }: {
    swapFee: Decimal;
    tokenIn: Coin;
    tokenOutDenom: string;
  }): Promise<CalcOutAmtGivenInResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      calc_out_amt_given_in: {
        swap_fee: swapFee,
        token_in: tokenIn,
        token_out_denom: tokenOutDenom
      }
    });
  };
  calcInAmtGivenOut = async ({
    swapFee,
    tokenInDenom,
    tokenOut
  }: {
    swapFee: Decimal;
    tokenInDenom: string;
    tokenOut: Coin;
  }): Promise<CalcInAmtGivenOutResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      calc_in_amt_given_out: {
        swap_fee: swapFee,
        token_in_denom: tokenInDenom,
        token_out: tokenOut
      }
    });
  };
  getAdmin = async (): Promise<GetAdminResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_admin: {}
    });
  };
  getAdminCandidate = async (): Promise<GetAdminCandidateResponse> => {
    return this.client.queryContractSmart(this.contractAddress, {
      get_admin_candidate: {}
    });
  };
}
export interface TransmuterInterface extends TransmuterReadOnlyInterface {
  contractAddress: string;
  sender: string;
  setActiveStatus: ({
    active
  }: {
    active: boolean;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  joinPool: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  exitPool: ({
    tokensOut
  }: {
    tokensOut: Coin[];
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  transferAdmin: ({
    candidate
  }: {
    candidate: string;
  }, fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
  claimAdmin: (fee?: number | StdFee | "auto", memo?: string, funds?: Coin[]) => Promise<ExecuteResult>;
}
export class TransmuterClient extends TransmuterQueryClient implements TransmuterInterface {
  client: SigningCosmWasmClient;
  sender: string;
  contractAddress: string;

  constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string) {
    super(client, contractAddress);
    this.client = client;
    this.sender = sender;
    this.contractAddress = contractAddress;
    this.setActiveStatus = this.setActiveStatus.bind(this);
    this.joinPool = this.joinPool.bind(this);
    this.exitPool = this.exitPool.bind(this);
    this.transferAdmin = this.transferAdmin.bind(this);
    this.claimAdmin = this.claimAdmin.bind(this);
  }

  setActiveStatus = async ({
    active
  }: {
    active: boolean;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      set_active_status: {
        active
      }
    }, fee, memo, funds);
  };
  joinPool = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      join_pool: {}
    }, fee, memo, funds);
  };
  exitPool = async ({
    tokensOut
  }: {
    tokensOut: Coin[];
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      exit_pool: {
        tokens_out: tokensOut
      }
    }, fee, memo, funds);
  };
  transferAdmin = async ({
    candidate
  }: {
    candidate: string;
  }, fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      transfer_admin: {
        candidate
      }
    }, fee, memo, funds);
  };
  claimAdmin = async (fee: number | StdFee | "auto" = "auto", memo?: string, funds?: Coin[]): Promise<ExecuteResult> => {
    return await this.client.execute(this.sender, this.contractAddress, {
      claim_admin: {}
    }, fee, memo, funds);
  };
}